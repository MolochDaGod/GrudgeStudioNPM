import{aI as te,V as E,aJ as lt,x as pe,y as ct,z as Ne,Y as ut,I as Re,ab as Oe,aK as pt,Q as ce,aL as ft,J as K,h as U,K as k,aM as ht,j as P,G as Fe,aN as Be,a3 as fe,aD as ie,as as mt,r as Ve,d as D,t as dt,n as gt,aO as yt,b as be,am as ue,aw as vt,aP as wt,m as xt,B as $,F as O,aQ as Tt,aR as It,f as Ft,aS as bt,aF as W,aT as At,Z as X,aU as Pt,aV as je,aW as St,aX as ze,aA as ae,ak as Ue,aB as ye}from"./OrbitControls-BM5tREKB.js";var B=Uint8Array,J=Uint16Array,Lt=Int32Array,qe=new B([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]),Qe=new B([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0]),Et=new B([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),Ye=function(u,e){for(var t=new J(31),n=0;n<31;++n)t[n]=e+=1<<u[n-1];for(var r=new Lt(t[30]),n=1;n<30;++n)for(var s=t[n];s<t[n+1];++s)r[s]=s-t[n]<<5|n;return{b:t,r}},Je=Ye(qe,2),Ze=Je.b,Ct=Je.r;Ze[28]=258,Ct[258]=28;var Mt=Ye(Qe,0),Dt=Mt.b,Ae=new J(32768);for(var F=0;F<32768;++F){var H=(F&43690)>>1|(F&21845)<<1;H=(H&52428)>>2|(H&13107)<<2,H=(H&61680)>>4|(H&3855)<<4,Ae[F]=((H&65280)>>8|(H&255)<<8)>>1}var ee=(function(u,e,t){for(var n=u.length,r=0,s=new J(e);r<n;++r)u[r]&&++s[u[r]-1];var i=new J(e);for(r=1;r<e;++r)i[r]=i[r-1]+s[r-1]<<1;var a;if(t){a=new J(1<<e);var l=15-e;for(r=0;r<n;++r)if(u[r])for(var c=r<<4|u[r],f=e-u[r],o=i[u[r]-1]++<<f,p=o|(1<<f)-1;o<=p;++o)a[Ae[o]>>l]=c}else for(a=new J(n),r=0;r<n;++r)u[r]&&(a[r]=Ae[i[u[r]-1]++]>>15-u[r]);return a}),re=new B(288);for(var F=0;F<144;++F)re[F]=8;for(var F=144;F<256;++F)re[F]=9;for(var F=256;F<280;++F)re[F]=7;for(var F=280;F<288;++F)re[F]=8;var $e=new B(32);for(var F=0;F<32;++F)$e[F]=5;var kt=ee(re,9,1),Rt=ee($e,5,1),ve=function(u){for(var e=u[0],t=1;t<u.length;++t)u[t]>e&&(e=u[t]);return e},V=function(u,e,t){var n=e/8|0;return(u[n]|u[n+1]<<8)>>(e&7)&t},we=function(u,e){var t=e/8|0;return(u[t]|u[t+1]<<8|u[t+2]<<16)>>(e&7)},Ot=function(u){return(u+7)/8|0},Bt=function(u,e,t){return(t==null||t>u.length)&&(t=u.length),new B(u.subarray(e,t))},Vt=["unexpected EOF","invalid block type","invalid length/literal","invalid distance","stream finished","no stream handler",,"no callback","invalid UTF-8 data","extra field too long","date not in range 1980-2099","filename too long","stream finishing","invalid zip data"],j=function(u,e,t){var n=new Error(e||Vt[u]);if(n.code=u,Error.captureStackTrace&&Error.captureStackTrace(n,j),!t)throw n;return n},jt=function(u,e,t,n){var r=u.length,s=0;if(!r||e.f&&!e.l)return t||new B(0);var i=!t,a=i||e.i!=2,l=e.i;i&&(t=new B(r*3));var c=function(Me){var De=t.length;if(Me>De){var ke=new B(Math.max(De*2,Me));ke.set(t),t=ke}},f=e.f||0,o=e.p||0,p=e.b||0,h=e.l,m=e.d,d=e.m,g=e.n,v=r*8;do{if(!h){f=V(u,o,1);var x=V(u,o+1,3);if(o+=3,x)if(x==1)h=kt,m=Rt,d=9,g=5;else if(x==2){var w=V(u,o,31)+257,A=V(u,o+10,15)+4,C=w+V(u,o+5,31)+1;o+=14;for(var z=new B(C),_=new B(19),b=0;b<A;++b)_[Et[b]]=V(u,o+b*3,7);o+=A*3;for(var N=ve(_),he=(1<<N)-1,st=ee(_,N,1),b=0;b<C;){var Pe=st[V(u,o,he)];o+=Pe&15;var y=Pe>>4;if(y<16)z[b++]=y;else{var q=0,se=0;for(y==16?(se=3+V(u,o,3),o+=2,q=z[b-1]):y==17?(se=3+V(u,o,7),o+=3):y==18&&(se=11+V(u,o,127),o+=7);se--;)z[b++]=q}}var Se=z.subarray(0,w),G=z.subarray(w);d=ve(Se),g=ve(G),h=ee(Se,d,1),m=ee(G,g,1)}else j(1);else{var y=Ot(o)+4,I=u[y-4]|u[y-3]<<8,L=y+I;if(L>r){l&&j(0);break}a&&c(p+I),t.set(u.subarray(y,L),p),e.b=p+=I,e.p=o=L*8,e.f=f;continue}if(o>v){l&&j(0);break}}a&&c(p+131072);for(var it=(1<<d)-1,at=(1<<g)-1,me=o;;me=o){var q=h[we(u,o)&it],Q=q>>4;if(o+=q&15,o>v){l&&j(0);break}if(q||j(2),Q<256)t[p++]=Q;else if(Q==256){me=o,h=null;break}else{var Le=Q-254;if(Q>264){var b=Q-257,Z=qe[b];Le=V(u,o,(1<<Z)-1)+Ze[b],o+=Z}var de=m[we(u,o)&at],ge=de>>4;de||j(3),o+=de&15;var G=Dt[ge];if(ge>3){var Z=Qe[ge];G+=we(u,o)&(1<<Z)-1,o+=Z}if(o>v){l&&j(0);break}a&&c(p+131072);var Ee=p+Le;if(p<G){var Ce=s-G,ot=Math.min(G,Ee);for(Ce+p<0&&j(3);p<ot;++p)t[p]=n[Ce+p]}for(;p<Ee;++p)t[p]=t[p-G]}}e.l=h,e.p=me,e.b=p,e.f=f,h&&(f=1,e.m=d,e.d=m,e.n=g)}while(!f);return p!=t.length&&i?Bt(t,0,p):t.subarray(0,p)},zt=new B(0),Ut=function(u,e){return((u[0]&15)!=8||u[0]>>4>7||(u[0]<<8|u[1])%31)&&j(6,"invalid zlib data"),(u[1]>>5&1)==1&&j(6,"invalid zlib data: "+(u[1]&32?"need":"unexpected")+" dictionary"),(u[1]>>3&4)+2};function _t(u,e){return jt(u.subarray(Ut(u),-4),{i:2},e,e)}var Gt=typeof TextDecoder<"u"&&new TextDecoder,Xt=0;try{Gt.decode(zt,{stream:!0}),Xt=1}catch{}function et(u,e,t){const n=t.length-u-1;if(e>=t[n])return n-1;if(e<=t[u])return u;let r=u,s=n,i=Math.floor((r+s)/2);for(;e<t[i]||e>=t[i+1];)e<t[i]?s=i:r=i,i=Math.floor((r+s)/2);return i}function Ht(u,e,t,n){const r=[],s=[],i=[];r[0]=1;for(let a=1;a<=t;++a){s[a]=e-n[u+1-a],i[a]=n[u+a]-e;let l=0;for(let c=0;c<a;++c){const f=i[c+1],o=s[a-c],p=r[c]/(f+o);r[c]=l+f*p,l=o*p}r[a]=l}return r}function Kt(u,e,t,n){const r=et(u,n,e),s=Ht(r,n,u,e),i=new te(0,0,0,0);for(let a=0;a<=u;++a){const l=t[r-u+a],c=s[a],f=l.w*c;i.x+=l.x*f,i.y+=l.y*f,i.z+=l.z*f,i.w+=l.w*c}return i}function Wt(u,e,t,n,r){const s=[];for(let o=0;o<=t;++o)s[o]=0;const i=[];for(let o=0;o<=n;++o)i[o]=s.slice(0);const a=[];for(let o=0;o<=t;++o)a[o]=s.slice(0);a[0][0]=1;const l=s.slice(0),c=s.slice(0);for(let o=1;o<=t;++o){l[o]=e-r[u+1-o],c[o]=r[u+o]-e;let p=0;for(let h=0;h<o;++h){const m=c[h+1],d=l[o-h];a[o][h]=m+d;const g=a[h][o-1]/a[o][h];a[h][o]=p+m*g,p=d*g}a[o][o]=p}for(let o=0;o<=t;++o)i[0][o]=a[o][t];for(let o=0;o<=t;++o){let p=0,h=1;const m=[];for(let d=0;d<=t;++d)m[d]=s.slice(0);m[0][0]=1;for(let d=1;d<=n;++d){let g=0;const v=o-d,x=t-d;o>=d&&(m[h][0]=m[p][0]/a[x+1][v],g=m[h][0]*a[v][x]);const y=v>=-1?1:-v,I=o-1<=x?d-1:t-o;for(let w=y;w<=I;++w)m[h][w]=(m[p][w]-m[p][w-1])/a[x+1][v+w],g+=m[h][w]*a[v+w][x];o<=x&&(m[h][d]=-m[p][d-1]/a[x+1][o],g+=m[h][d]*a[o][x]),i[d][o]=g;const L=p;p=h,h=L}}let f=t;for(let o=1;o<=n;++o){for(let p=0;p<=t;++p)i[o][p]*=f;f*=t-o}return i}function Nt(u,e,t,n,r){const s=r<u?r:u,i=[],a=et(u,n,e),l=Wt(a,n,u,s,e),c=[];for(let f=0;f<t.length;++f){const o=t[f].clone(),p=o.w;o.x*=p,o.y*=p,o.z*=p,c[f]=o}for(let f=0;f<=s;++f){const o=c[a-u].clone().multiplyScalar(l[f][0]);for(let p=1;p<=u;++p)o.add(c[a-u+p].clone().multiplyScalar(l[f][p]));i[f]=o}for(let f=s+1;f<=r+1;++f)i[f]=new te(0,0,0);return i}function qt(u,e){let t=1;for(let r=2;r<=u;++r)t*=r;let n=1;for(let r=2;r<=e;++r)n*=r;for(let r=2;r<=u-e;++r)n*=r;return t/n}function Qt(u){const e=u.length,t=[],n=[];for(let s=0;s<e;++s){const i=u[s];t[s]=new E(i.x,i.y,i.z),n[s]=i.w}const r=[];for(let s=0;s<e;++s){const i=t[s].clone();for(let a=1;a<=s;++a)i.sub(r[s-a].clone().multiplyScalar(qt(s,a)*n[a]));r[s]=i.divideScalar(n[0])}return r}function Yt(u,e,t,n,r){const s=Nt(u,e,t,n,r);return Qt(s)}class Jt extends lt{constructor(e,t,n,r,s){super();const i=t?t.length-1:0,a=n?n.length:0;this.degree=e,this.knots=t,this.controlPoints=[],this.startKnot=r||0,this.endKnot=s||i;for(let l=0;l<a;++l){const c=n[l];this.controlPoints[l]=new te(c.x,c.y,c.z,c.w)}}getPoint(e,t=new E){const n=t,r=this.knots[this.startKnot]+e*(this.knots[this.endKnot]-this.knots[this.startKnot]),s=Kt(this.degree,this.knots,this.controlPoints,r);return s.w!==1&&s.divideScalar(s.w),n.set(s.x,s.y,s.z)}getTangent(e,t=new E){const n=t,r=this.knots[0]+e*(this.knots[this.knots.length-1]-this.knots[0]),s=Yt(this.degree,this.knots,this.controlPoints,r,1);return n.copy(s[1]).normalize(),n}toJSON(){const e=super.toJSON();return e.degree=this.degree,e.knots=[...this.knots],e.controlPoints=this.controlPoints.map(t=>t.toArray()),e.startKnot=this.startKnot,e.endKnot=this.endKnot,e}fromJSON(e){return super.fromJSON(e),this.degree=e.degree,this.knots=[...e.knots],this.controlPoints=e.controlPoints.map(t=>new te(t[0],t[1],t[2],t[3])),this.startKnot=e.startKnot,this.endKnot=e.endKnot,this}}let T,S,M;class gn extends pe{constructor(e){super(e)}load(e,t,n,r){const s=this,i=s.path===""?ct.extractUrlBase(e):s.path,a=new Ne(this.manager);a.setPath(s.path),a.setResponseType("arraybuffer"),a.setRequestHeader(s.requestHeader),a.setWithCredentials(s.withCredentials),a.load(e,function(l){try{t(s.parse(l,i))}catch(c){r?r(c):console.error(c),s.manager.itemError(e)}},n,r)}parse(e,t){if(rn(e))T=new nn().parse(e);else{const r=rt(e);if(!sn(r))throw new Error("THREE.FBXLoader: Unknown format.");if(Ge(r)<7e3)throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: "+Ge(r));T=new tn().parse(r)}const n=new ut(this.manager).setPath(this.resourcePath||t).setCrossOrigin(this.crossOrigin);return new Zt(n,this.manager).parse(T)}}class Zt{constructor(e,t){this.textureLoader=e,this.manager=t}parse(){S=this.parseConnections();const e=this.parseImages(),t=this.parseTextures(e),n=this.parseMaterials(t),r=this.parseDeformers(),s=new $t().parse(r);return this.parseScene(r,s,n),M}parseConnections(){const e=new Map;return"Connections"in T&&T.Connections.connections.forEach(function(n){const r=n[0],s=n[1],i=n[2];e.has(r)||e.set(r,{parents:[],children:[]});const a={ID:s,relationship:i};e.get(r).parents.push(a),e.has(s)||e.set(s,{parents:[],children:[]});const l={ID:r,relationship:i};e.get(s).children.push(l)}),e}parseImages(){const e={},t={};if("Video"in T.Objects){const n=T.Objects.Video;for(const r in n){const s=n[r],i=parseInt(r);if(e[i]=s.RelativeFilename||s.Filename,"Content"in s){const a=s.Content instanceof ArrayBuffer&&s.Content.byteLength>0,l=typeof s.Content=="string"&&s.Content!=="";if(a||l){const c=this.parseImage(n[r]);t[s.RelativeFilename||s.Filename]=c}}}}for(const n in e){const r=e[n];t[r]!==void 0?e[n]=t[r]:e[n]=e[n].split("\\").pop()}return e}parseImage(e){const t=e.Content,n=e.RelativeFilename||e.Filename,r=n.slice(n.lastIndexOf(".")+1).toLowerCase();let s;switch(r){case"bmp":s="image/bmp";break;case"jpg":case"jpeg":s="image/jpeg";break;case"png":s="image/png";break;case"tif":s="image/tiff";break;case"tga":this.manager.getHandler(".tga")===null&&console.warn("FBXLoader: TGA loader not found, skipping ",n),s="image/tga";break;default:console.warn('FBXLoader: Image type "'+r+'" is not supported.');return}if(typeof t=="string")return"data:"+s+";base64,"+t;{const i=new Uint8Array(t);return window.URL.createObjectURL(new Blob([i],{type:s}))}}parseTextures(e){const t=new Map;if("Texture"in T.Objects){const n=T.Objects.Texture;for(const r in n){const s=this.parseTexture(n[r],e);t.set(parseInt(r),s)}}return t}parseTexture(e,t){const n=this.loadTexture(e,t);n.ID=e.id,n.name=e.attrName;const r=e.WrapModeU,s=e.WrapModeV,i=r!==void 0?r.value:0,a=s!==void 0?s.value:0;if(n.wrapS=i===0?Re:Oe,n.wrapT=a===0?Re:Oe,"Scaling"in e){const l=e.Scaling.value;n.repeat.x=l[0],n.repeat.y=l[1]}if("Translation"in e){const l=e.Translation.value;n.offset.x=l[0],n.offset.y=l[1]}return n}loadTexture(e,t){const n=new Set(["tga","tif","tiff","exr","dds","hdr","ktx2"]),r=e.FileName.split(".").pop().toLowerCase(),s=n.has(r)?this.manager.getHandler(`.${r}`):this.textureLoader;if(!s)return console.warn(`FBXLoader: ${r.toUpperCase()} loader not found, creating placeholder texture for`,e.RelativeFilename),new pt;const i=s.path;i||s.setPath(this.textureLoader.path);const a=S.get(e.id).children;let l;a!==void 0&&a.length>0&&t[a[0].ID]!==void 0&&(l=t[a[0].ID],(l.indexOf("blob:")===0||l.indexOf("data:")===0)&&s.setPath(void 0));const c=s.load(l);return s.setPath(i),c}parseMaterials(e){const t=new Map;if("Material"in T.Objects){const n=T.Objects.Material;for(const r in n){const s=this.parseMaterial(n[r],e);s!==null&&t.set(parseInt(r),s)}}return t}parseMaterial(e,t){const n=e.id,r=e.attrName;let s=e.ShadingModel;if(typeof s=="object"&&(s=s.value),!S.has(n))return null;const i=this.parseParameters(e,t,n);let a;switch(s.toLowerCase()){case"phong":a=new ce;break;case"lambert":a=new ft;break;default:console.warn('THREE.FBXLoader: unknown material type "%s". Defaulting to MeshPhongMaterial.',s),a=new ce;break}return a.setValues(i),a.name=r,a}parseParameters(e,t,n){const r={};e.BumpFactor&&(r.bumpScale=e.BumpFactor.value),e.Diffuse?r.color=K.toWorkingColorSpace(new U().fromArray(e.Diffuse.value),k):e.DiffuseColor&&(e.DiffuseColor.type==="Color"||e.DiffuseColor.type==="ColorRGB")&&(r.color=K.toWorkingColorSpace(new U().fromArray(e.DiffuseColor.value),k)),e.DisplacementFactor&&(r.displacementScale=e.DisplacementFactor.value),e.Emissive?r.emissive=K.toWorkingColorSpace(new U().fromArray(e.Emissive.value),k):e.EmissiveColor&&(e.EmissiveColor.type==="Color"||e.EmissiveColor.type==="ColorRGB")&&(r.emissive=K.toWorkingColorSpace(new U().fromArray(e.EmissiveColor.value),k)),e.EmissiveFactor&&(r.emissiveIntensity=parseFloat(e.EmissiveFactor.value)),r.opacity=1-(e.TransparencyFactor?parseFloat(e.TransparencyFactor.value):0),(r.opacity===1||r.opacity===0)&&(r.opacity=e.Opacity?parseFloat(e.Opacity.value):null,r.opacity===null&&(r.opacity=1-(e.TransparentColor?parseFloat(e.TransparentColor.value[0]):0))),r.opacity<1&&(r.transparent=!0),e.ReflectionFactor&&(r.reflectivity=e.ReflectionFactor.value),e.Shininess&&(r.shininess=e.Shininess.value),e.Specular?r.specular=K.toWorkingColorSpace(new U().fromArray(e.Specular.value),k):e.SpecularColor&&e.SpecularColor.type==="Color"&&(r.specular=K.toWorkingColorSpace(new U().fromArray(e.SpecularColor.value),k));const s=this;return S.get(n).children.forEach(function(i){const a=i.relationship;switch(a){case"Bump":r.bumpMap=s.getTexture(t,i.ID);break;case"Maya|TEX_ao_map":r.aoMap=s.getTexture(t,i.ID);break;case"DiffuseColor":case"Maya|TEX_color_map":r.map=s.getTexture(t,i.ID),r.map!==void 0&&(r.map.colorSpace=k);break;case"DisplacementColor":r.displacementMap=s.getTexture(t,i.ID);break;case"EmissiveColor":r.emissiveMap=s.getTexture(t,i.ID),r.emissiveMap!==void 0&&(r.emissiveMap.colorSpace=k);break;case"NormalMap":case"Maya|TEX_normal_map":r.normalMap=s.getTexture(t,i.ID);break;case"ReflectionColor":r.envMap=s.getTexture(t,i.ID),r.envMap!==void 0&&(r.envMap.mapping=ht,r.envMap.colorSpace=k);break;case"SpecularColor":r.specularMap=s.getTexture(t,i.ID),r.specularMap!==void 0&&(r.specularMap.colorSpace=k);break;case"TransparentColor":case"TransparencyFactor":r.alphaMap=s.getTexture(t,i.ID),r.transparent=!0;break;case"AmbientColor":case"ShininessExponent":case"SpecularFactor":case"VectorDisplacementColor":default:console.warn("THREE.FBXLoader: %s map is not supported in three.js, skipping texture.",a);break}}),r}getTexture(e,t){return"LayeredTexture"in T.Objects&&t in T.Objects.LayeredTexture&&(console.warn("THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer."),t=S.get(t).children[0].ID),e.get(t)}parseDeformers(){const e={},t={};if("Deformer"in T.Objects){const n=T.Objects.Deformer;for(const r in n){const s=n[r],i=S.get(parseInt(r));if(s.attrType==="Skin"){const a=this.parseSkeleton(i,n);a.ID=r,i.parents.length>1&&console.warn("THREE.FBXLoader: skeleton attached to more than one geometry is not supported."),a.geometryID=i.parents[0].ID,e[r]=a}else if(s.attrType==="BlendShape"){const a={id:r};a.rawTargets=this.parseMorphTargets(i,n),a.id=r,i.parents.length>1&&console.warn("THREE.FBXLoader: morph target attached to more than one geometry is not supported."),t[r]=a}}}return{skeletons:e,morphTargets:t}}parseSkeleton(e,t){const n=[];return e.children.forEach(function(r){const s=t[r.ID];if(s.attrType!=="Cluster")return;const i={ID:r.ID,indices:[],weights:[],transformLink:new P().fromArray(s.TransformLink.a)};"Indexes"in s&&(i.indices=s.Indexes.a,i.weights=s.Weights.a),n.push(i)}),{rawBones:n,bones:[]}}parseMorphTargets(e,t){const n=[];for(let r=0;r<e.children.length;r++){const s=e.children[r],i=t[s.ID],a={name:i.attrName,initialWeight:i.DeformPercent,id:i.id,fullWeights:i.FullWeights.a};if(i.attrType!=="BlendShapeChannel")return;a.geoID=S.get(parseInt(s.ID)).children.filter(function(l){return l.relationship===void 0})[0].ID,n.push(a)}return n}parseScene(e,t,n){M=new Fe;const r=this.parseModels(e.skeletons,t,n),s=T.Objects.Model,i=this;r.forEach(function(l){const c=s[l.ID];i.setLookAtProperties(l,c),S.get(l.ID).parents.forEach(function(o){const p=r.get(o.ID);p!==void 0&&p.add(l)}),l.parent===null&&M.add(l)}),this.bindSkeleton(e.skeletons,t,r),this.addGlobalSceneSettings(),M.traverse(function(l){if(l.userData.transformData){l.parent&&(l.userData.transformData.parentMatrix=l.parent.matrix,l.userData.transformData.parentMatrixWorld=l.parent.matrixWorld);const c=nt(l.userData.transformData);l.applyMatrix4(c),l.updateWorldMatrix()}});const a=new en().parse();M.children.length===1&&M.children[0].isGroup&&(M.children[0].animations=a,M=M.children[0]),M.animations=a}parseModels(e,t,n){const r=new Map,s=T.Objects.Model;for(const i in s){const a=parseInt(i),l=s[i],c=S.get(a);let f=this.buildSkeleton(c,e,a,l.attrName);if(!f){switch(l.attrType){case"Camera":f=this.createCamera(c);break;case"Light":f=this.createLight(c);break;case"Mesh":f=this.createMesh(c,t,n);break;case"NurbsCurve":f=this.createCurve(c,t);break;case"LimbNode":case"Root":f=new Be;break;case"Null":default:f=new Fe;break}f.name=l.attrName?fe.sanitizeNodeName(l.attrName):"",f.userData.originalName=l.attrName,f.ID=a}this.getTransformData(f,l),r.set(a,f)}return r}buildSkeleton(e,t,n,r){let s=null;return e.parents.forEach(function(i){for(const a in t){const l=t[a];l.rawBones.forEach(function(c,f){if(c.ID===i.ID){const o=s;s=new Be,s.matrixWorld.copy(c.transformLink),s.name=r?fe.sanitizeNodeName(r):"",s.userData.originalName=r,s.ID=n,l.bones[f]=s,o!==null&&s.add(o)}})}}),s}createCamera(e){let t,n;if(e.children.forEach(function(r){const s=T.Objects.NodeAttribute[r.ID];s!==void 0&&(n=s)}),n===void 0)t=new ie;else{let r=0;n.CameraProjectionType!==void 0&&n.CameraProjectionType.value===1&&(r=1);let s=1;n.NearPlane!==void 0&&(s=n.NearPlane.value/1e3);let i=1e3;n.FarPlane!==void 0&&(i=n.FarPlane.value/1e3);let a=window.innerWidth,l=window.innerHeight;n.AspectWidth!==void 0&&n.AspectHeight!==void 0&&(a=n.AspectWidth.value,l=n.AspectHeight.value);const c=a/l;let f=45;n.FieldOfView!==void 0&&(f=n.FieldOfView.value);const o=n.FocalLength?n.FocalLength.value:null;switch(r){case 0:t=new mt(f,c,s,i),o!==null&&t.setFocalLength(o);break;case 1:console.warn("THREE.FBXLoader: Orthographic cameras not supported yet."),t=new ie;break;default:console.warn("THREE.FBXLoader: Unknown camera type "+r+"."),t=new ie;break}}return t}createLight(e){let t,n;if(e.children.forEach(function(r){const s=T.Objects.NodeAttribute[r.ID];s!==void 0&&(n=s)}),n===void 0)t=new ie;else{let r;n.LightType===void 0?r=0:r=n.LightType.value;let s=16777215;n.Color!==void 0&&(s=K.toWorkingColorSpace(new U().fromArray(n.Color.value),k));let i=n.Intensity===void 0?1:n.Intensity.value/100;n.CastLightOnObject!==void 0&&n.CastLightOnObject.value===0&&(i=0);let a=0;n.FarAttenuationEnd!==void 0&&(n.EnableFarAttenuation!==void 0&&n.EnableFarAttenuation.value===0?a=0:a=n.FarAttenuationEnd.value);const l=1;switch(r){case 0:t=new Ve(s,i,a,l);break;case 1:t=new gt(s,i);break;case 2:let c=Math.PI/3;n.InnerAngle!==void 0&&(c=D.degToRad(n.InnerAngle.value));let f=0;n.OuterAngle!==void 0&&(f=D.degToRad(n.OuterAngle.value),f=Math.max(f,1)),t=new dt(s,i,a,c,f,l);break;default:console.warn("THREE.FBXLoader: Unknown light type "+n.LightType.value+", defaulting to a PointLight."),t=new Ve(s,i);break}n.CastShadows!==void 0&&n.CastShadows.value===1&&(t.castShadow=!0)}return t}createMesh(e,t,n){let r,s=null,i=null;const a=[];return e.children.forEach(function(l){t.has(l.ID)&&(s=t.get(l.ID)),n.has(l.ID)&&a.push(n.get(l.ID))}),a.length>1?i=a:a.length>0?i=a[0]:(i=new ce({name:pe.DEFAULT_MATERIAL_NAME,color:13421772}),a.push(i)),"color"in s.attributes&&a.forEach(function(l){l.vertexColors=!0}),s.FBX_Deformer?(r=new yt(s,i),r.normalizeSkinWeights()):r=new be(s,i),r}createCurve(e,t){const n=e.children.reduce(function(s,i){return t.has(i.ID)&&(s=t.get(i.ID)),s},null),r=new ue({name:pe.DEFAULT_MATERIAL_NAME,color:3342591,linewidth:1});return new vt(n,r)}getTransformData(e,t){const n={};"InheritType"in t&&(n.inheritType=parseInt(t.InheritType.value)),"RotationOrder"in t?n.eulerOrder=ne(t.RotationOrder.value):n.eulerOrder=ne(0),"Lcl_Translation"in t&&(n.translation=t.Lcl_Translation.value),"PreRotation"in t&&(n.preRotation=t.PreRotation.value),"Lcl_Rotation"in t&&(n.rotation=t.Lcl_Rotation.value),"PostRotation"in t&&(n.postRotation=t.PostRotation.value),"Lcl_Scaling"in t&&(n.scale=t.Lcl_Scaling.value),"ScalingOffset"in t&&(n.scalingOffset=t.ScalingOffset.value),"ScalingPivot"in t&&(n.scalingPivot=t.ScalingPivot.value),"RotationOffset"in t&&(n.rotationOffset=t.RotationOffset.value),"RotationPivot"in t&&(n.rotationPivot=t.RotationPivot.value),e.userData.transformData=n}setLookAtProperties(e,t){"LookAtProperty"in t&&S.get(e.ID).children.forEach(function(r){if(r.relationship==="LookAtProperty"){const s=T.Objects.Model[r.ID];if("Lcl_Translation"in s){const i=s.Lcl_Translation.value;e.target!==void 0?(e.target.position.fromArray(i),M.add(e.target)):e.lookAt(new E().fromArray(i))}}})}bindSkeleton(e,t,n){const r=this.parsePoseNodes();for(const s in e){const i=e[s];S.get(parseInt(i.ID)).parents.forEach(function(l){if(t.has(l.ID)){const c=l.ID;S.get(c).parents.forEach(function(o){n.has(o.ID)&&n.get(o.ID).bind(new wt(i.bones),r[o.ID])})}})}}parsePoseNodes(){const e={};if("Pose"in T.Objects){const t=T.Objects.Pose;for(const n in t)if(t[n].attrType==="BindPose"&&t[n].NbPoseNodes>0){const r=t[n].PoseNode;Array.isArray(r)?r.forEach(function(s){e[s.Node]=new P().fromArray(s.Matrix.a)}):e[r.Node]=new P().fromArray(r.Matrix.a)}}return e}addGlobalSceneSettings(){if("GlobalSettings"in T){if("AmbientColor"in T.GlobalSettings){const e=T.GlobalSettings.AmbientColor.value,t=e[0],n=e[1],r=e[2];if(t!==0||n!==0||r!==0){const s=new U().setRGB(t,n,r,k);M.add(new xt(s,1))}}"UnitScaleFactor"in T.GlobalSettings&&(M.userData.unitScaleFactor=T.GlobalSettings.UnitScaleFactor.value)}}}class $t{constructor(){this.negativeMaterialIndices=!1}parse(e){const t=new Map;if("Geometry"in T.Objects){const n=T.Objects.Geometry;for(const r in n){const s=S.get(parseInt(r)),i=this.parseGeometry(s,n[r],e);t.set(parseInt(r),i)}}return this.negativeMaterialIndices===!0&&console.warn("THREE.FBXLoader: The FBX file contains invalid (negative) material indices. The asset might not render as expected."),t}parseGeometry(e,t,n){switch(t.attrType){case"Mesh":return this.parseMeshGeometry(e,t,n);case"NurbsCurve":return this.parseNurbsGeometry(t)}}parseMeshGeometry(e,t,n){const r=n.skeletons,s=[],i=e.parents.map(function(o){return T.Objects.Model[o.ID]});if(i.length===0)return;const a=e.children.reduce(function(o,p){return r[p.ID]!==void 0&&(o=r[p.ID]),o},null);e.children.forEach(function(o){n.morphTargets[o.ID]!==void 0&&s.push(n.morphTargets[o.ID])});const l=i[0],c={};"RotationOrder"in l&&(c.eulerOrder=ne(l.RotationOrder.value)),"InheritType"in l&&(c.inheritType=parseInt(l.InheritType.value)),"GeometricTranslation"in l&&(c.translation=l.GeometricTranslation.value),"GeometricRotation"in l&&(c.rotation=l.GeometricRotation.value),"GeometricScaling"in l&&(c.scale=l.GeometricScaling.value);const f=nt(c);return this.genGeometry(t,a,s,f)}genGeometry(e,t,n,r){const s=new $;e.attrName&&(s.name=e.attrName);const i=this.parseGeoNode(e,t),a=this.genBuffers(i),l=new O(a.vertex,3);if(l.applyMatrix4(r),s.setAttribute("position",l),a.colors.length>0&&s.setAttribute("color",new O(a.colors,3)),t&&(s.setAttribute("skinIndex",new Tt(a.weightsIndices,4)),s.setAttribute("skinWeight",new O(a.vertexWeights,4)),s.FBX_Deformer=t),a.normal.length>0){const c=new It().getNormalMatrix(r),f=new O(a.normal,3);f.applyNormalMatrix(c),s.setAttribute("normal",f)}if(a.uvs.forEach(function(c,f){const o=f===0?"uv":`uv${f}`;s.setAttribute(o,new O(a.uvs[f],2))}),i.material&&i.material.mappingType!=="AllSame"){let c=a.materialIndex[0],f=0;if(a.materialIndex.forEach(function(o,p){o!==c&&(s.addGroup(f,p-f,c),c=o,f=p)}),s.groups.length>0){const o=s.groups[s.groups.length-1],p=o.start+o.count;p!==a.materialIndex.length&&s.addGroup(p,a.materialIndex.length-p,c)}s.groups.length===0&&s.addGroup(0,a.materialIndex.length,a.materialIndex[0])}return this.addMorphTargets(s,e,n,r),s}parseGeoNode(e,t){const n={};if(n.vertexPositions=e.Vertices!==void 0?e.Vertices.a:[],n.vertexIndices=e.PolygonVertexIndex!==void 0?e.PolygonVertexIndex.a:[],e.LayerElementColor&&(n.color=this.parseVertexColors(e.LayerElementColor[0])),e.LayerElementMaterial&&(n.material=this.parseMaterialIndices(e.LayerElementMaterial[0])),e.LayerElementNormal&&(n.normal=this.parseNormals(e.LayerElementNormal[0])),e.LayerElementUV){n.uv=[];let r=0;for(;e.LayerElementUV[r];)e.LayerElementUV[r].UV&&n.uv.push(this.parseUVs(e.LayerElementUV[r])),r++}return n.weightTable={},t!==null&&(n.skeleton=t,t.rawBones.forEach(function(r,s){r.indices.forEach(function(i,a){n.weightTable[i]===void 0&&(n.weightTable[i]=[]),n.weightTable[i].push({id:s,weight:r.weights[a]})})})),n}genBuffers(e){const t={vertex:[],normal:[],colors:[],uvs:[],materialIndex:[],vertexWeights:[],weightsIndices:[]};let n=0,r=0,s=!1,i=[],a=[],l=[],c=[],f=[],o=[];const p=this;return e.vertexIndices.forEach(function(h,m){let d,g=!1;h<0&&(h=h^-1,g=!0);let v=[],x=[];if(i.push(h*3,h*3+1,h*3+2),e.color){const y=oe(m,n,h,e.color);l.push(y[0],y[1],y[2])}if(e.skeleton){if(e.weightTable[h]!==void 0&&e.weightTable[h].forEach(function(y){x.push(y.weight),v.push(y.id)}),x.length>4){s||(console.warn("THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights."),s=!0);const y=[0,0,0,0],I=[0,0,0,0];x.forEach(function(L,w){let A=L,C=v[w];I.forEach(function(z,_,b){if(A>z){b[_]=A,A=z;const N=y[_];y[_]=C,C=N}})}),v=y,x=I}for(;x.length<4;)x.push(0),v.push(0);for(let y=0;y<4;++y)f.push(x[y]),o.push(v[y])}if(e.normal){const y=oe(m,n,h,e.normal);a.push(y[0],y[1],y[2])}e.material&&e.material.mappingType!=="AllSame"&&(d=oe(m,n,h,e.material)[0],d<0&&(p.negativeMaterialIndices=!0,d=0)),e.uv&&e.uv.forEach(function(y,I){const L=oe(m,n,h,y);c[I]===void 0&&(c[I]=[]),c[I].push(L[0]),c[I].push(L[1])}),r++,g&&(p.genFace(t,e,i,d,a,l,c,f,o,r),n++,r=0,i=[],a=[],l=[],c=[],f=[],o=[])}),t}getNormalNewell(e){const t=new E(0,0,0);for(let n=0;n<e.length;n++){const r=e[n],s=e[(n+1)%e.length];t.x+=(r.y-s.y)*(r.z+s.z),t.y+=(r.z-s.z)*(r.x+s.x),t.z+=(r.x-s.x)*(r.y+s.y)}return t.normalize(),t}getNormalTangentAndBitangent(e){const t=this.getNormalNewell(e),r=(Math.abs(t.z)>.5?new E(0,1,0):new E(0,0,1)).cross(t).normalize(),s=t.clone().cross(r).normalize();return{normal:t,tangent:r,bitangent:s}}flattenVertex(e,t,n){return new Ft(e.dot(t),e.dot(n))}genFace(e,t,n,r,s,i,a,l,c,f){let o;if(f>3){const p=[],h=t.baseVertexPositions||t.vertexPositions;for(let v=0;v<n.length;v+=3)p.push(new E(h[n[v]],h[n[v+1]],h[n[v+2]]));const{tangent:m,bitangent:d}=this.getNormalTangentAndBitangent(p),g=[];for(const v of p)g.push(this.flattenVertex(v,m,d));o=bt.triangulateShape(g,[])}else o=[[0,1,2]];for(const[p,h,m]of o)e.vertex.push(t.vertexPositions[n[p*3]]),e.vertex.push(t.vertexPositions[n[p*3+1]]),e.vertex.push(t.vertexPositions[n[p*3+2]]),e.vertex.push(t.vertexPositions[n[h*3]]),e.vertex.push(t.vertexPositions[n[h*3+1]]),e.vertex.push(t.vertexPositions[n[h*3+2]]),e.vertex.push(t.vertexPositions[n[m*3]]),e.vertex.push(t.vertexPositions[n[m*3+1]]),e.vertex.push(t.vertexPositions[n[m*3+2]]),t.skeleton&&(e.vertexWeights.push(l[p*4]),e.vertexWeights.push(l[p*4+1]),e.vertexWeights.push(l[p*4+2]),e.vertexWeights.push(l[p*4+3]),e.vertexWeights.push(l[h*4]),e.vertexWeights.push(l[h*4+1]),e.vertexWeights.push(l[h*4+2]),e.vertexWeights.push(l[h*4+3]),e.vertexWeights.push(l[m*4]),e.vertexWeights.push(l[m*4+1]),e.vertexWeights.push(l[m*4+2]),e.vertexWeights.push(l[m*4+3]),e.weightsIndices.push(c[p*4]),e.weightsIndices.push(c[p*4+1]),e.weightsIndices.push(c[p*4+2]),e.weightsIndices.push(c[p*4+3]),e.weightsIndices.push(c[h*4]),e.weightsIndices.push(c[h*4+1]),e.weightsIndices.push(c[h*4+2]),e.weightsIndices.push(c[h*4+3]),e.weightsIndices.push(c[m*4]),e.weightsIndices.push(c[m*4+1]),e.weightsIndices.push(c[m*4+2]),e.weightsIndices.push(c[m*4+3])),t.color&&(e.colors.push(i[p*3]),e.colors.push(i[p*3+1]),e.colors.push(i[p*3+2]),e.colors.push(i[h*3]),e.colors.push(i[h*3+1]),e.colors.push(i[h*3+2]),e.colors.push(i[m*3]),e.colors.push(i[m*3+1]),e.colors.push(i[m*3+2])),t.material&&t.material.mappingType!=="AllSame"&&(e.materialIndex.push(r),e.materialIndex.push(r),e.materialIndex.push(r)),t.normal&&(e.normal.push(s[p*3]),e.normal.push(s[p*3+1]),e.normal.push(s[p*3+2]),e.normal.push(s[h*3]),e.normal.push(s[h*3+1]),e.normal.push(s[h*3+2]),e.normal.push(s[m*3]),e.normal.push(s[m*3+1]),e.normal.push(s[m*3+2])),t.uv&&t.uv.forEach(function(d,g){e.uvs[g]===void 0&&(e.uvs[g]=[]),e.uvs[g].push(a[g][p*2]),e.uvs[g].push(a[g][p*2+1]),e.uvs[g].push(a[g][h*2]),e.uvs[g].push(a[g][h*2+1]),e.uvs[g].push(a[g][m*2]),e.uvs[g].push(a[g][m*2+1])})}addMorphTargets(e,t,n,r){if(n.length===0)return;e.morphTargetsRelative=!0,e.morphAttributes.position=[];const s=this;n.forEach(function(i){i.rawTargets.forEach(function(a){const l=T.Objects.Geometry[a.geoID];l!==void 0&&s.genMorphGeometry(e,t,l,r,a.name)})})}genMorphGeometry(e,t,n,r,s){const i=t.Vertices!==void 0?t.Vertices.a:[],a=t.PolygonVertexIndex!==void 0?t.PolygonVertexIndex.a:[],l=n.Vertices!==void 0?n.Vertices.a:[],c=n.Indexes!==void 0?n.Indexes.a:[],f=e.attributes.position.count*3,o=new Float32Array(f);for(let d=0;d<c.length;d++){const g=c[d]*3;o[g]=l[d*3],o[g+1]=l[d*3+1],o[g+2]=l[d*3+2]}const p={vertexIndices:a,vertexPositions:o,baseVertexPositions:i},h=this.genBuffers(p),m=new O(h.vertex,3);m.name=s||n.attrName,m.applyMatrix4(r),e.morphAttributes.position.push(m)}parseNormals(e){const t=e.MappingInformationType,n=e.ReferenceInformationType,r=e.Normals.a;let s=[];return n==="IndexToDirect"&&("NormalIndex"in e?s=e.NormalIndex.a:"NormalsIndex"in e&&(s=e.NormalsIndex.a)),{dataSize:3,buffer:r,indices:s,mappingType:t,referenceType:n}}parseUVs(e){const t=e.MappingInformationType,n=e.ReferenceInformationType,r=e.UV.a;let s=[];return n==="IndexToDirect"&&(s=e.UVIndex.a),{dataSize:2,buffer:r,indices:s,mappingType:t,referenceType:n}}parseVertexColors(e){const t=e.MappingInformationType,n=e.ReferenceInformationType,r=e.Colors.a;let s=[];n==="IndexToDirect"&&(s=e.ColorIndex.a);for(let i=0,a=new U;i<r.length;i+=4)a.fromArray(r,i),K.toWorkingColorSpace(a,k),a.toArray(r,i);return{dataSize:4,buffer:r,indices:s,mappingType:t,referenceType:n}}parseMaterialIndices(e){const t=e.MappingInformationType,n=e.ReferenceInformationType;if(t==="NoMappingInformation")return{dataSize:1,buffer:[0],indices:[0],mappingType:"AllSame",referenceType:n};const r=e.Materials.a,s=[];for(let i=0;i<r.length;++i)s.push(i);return{dataSize:1,buffer:r,indices:s,mappingType:t,referenceType:n}}parseNurbsGeometry(e){const t=parseInt(e.Order);if(isNaN(t))return console.error("THREE.FBXLoader: Invalid Order %s given for geometry ID: %s",e.Order,e.id),new $;const n=t-1,r=e.KnotVector.a,s=[],i=e.Points.a;for(let o=0,p=i.length;o<p;o+=4)s.push(new te().fromArray(i,o));let a,l;if(e.Form==="Closed")s.push(s[0]);else if(e.Form==="Periodic"){a=n,l=r.length-1-a;for(let o=0;o<n;++o)s.push(s[o])}const f=new Jt(n,r,s,a,l).getPoints(s.length*12);return new $().setFromPoints(f)}}class en{parse(){const e=[],t=this.parseClips();if(t!==void 0)for(const n in t){const r=t[n],s=this.addClip(r);e.push(s)}return e}parseClips(){if(T.Objects.AnimationCurve===void 0)return;const e=this.parseAnimationCurveNodes();this.parseAnimationCurves(e);const t=this.parseAnimationLayers(e);return this.parseAnimStacks(t)}parseAnimationCurveNodes(){const e=T.Objects.AnimationCurveNode,t=new Map;for(const n in e){const r=e[n];if(r.attrName.match(/S|R|T|DeformPercent/)!==null){const s={id:r.id,attr:r.attrName,curves:{}};t.set(s.id,s)}}return t}parseAnimationCurves(e){const t=T.Objects.AnimationCurve;for(const n in t){const r={id:t[n].id,times:t[n].KeyTime.a.map(an),values:t[n].KeyValueFloat.a},s=S.get(r.id);if(s!==void 0){const i=s.parents[0].ID,a=s.parents[0].relationship;a.match(/X/)?e.get(i).curves.x=r:a.match(/Y/)?e.get(i).curves.y=r:a.match(/Z/)?e.get(i).curves.z=r:a.match(/DeformPercent/)&&e.has(i)&&(e.get(i).curves.morph=r)}}}parseAnimationLayers(e){const t=T.Objects.AnimationLayer,n=new Map;for(const r in t){const s=[],i=S.get(parseInt(r));i!==void 0&&(i.children.forEach(function(l,c){if(e.has(l.ID)){const f=e.get(l.ID);if(f.curves.x!==void 0||f.curves.y!==void 0||f.curves.z!==void 0){if(s[c]===void 0){const o=S.get(l.ID).parents.filter(function(p){return p.relationship!==void 0})[0].ID;if(o!==void 0){const p=T.Objects.Model[o.toString()];if(p===void 0){console.warn("THREE.FBXLoader: Encountered a unused curve.",l);return}const h={modelName:p.attrName?fe.sanitizeNodeName(p.attrName):"",ID:p.id,initialPosition:[0,0,0],initialRotation:[0,0,0],initialScale:[1,1,1]};M.traverse(function(m){m.ID===p.id&&(h.transform=m.matrix,m.userData.transformData&&(h.eulerOrder=m.userData.transformData.eulerOrder))}),h.transform||(h.transform=new P),"PreRotation"in p&&(h.preRotation=p.PreRotation.value),"PostRotation"in p&&(h.postRotation=p.PostRotation.value),s[c]=h}}s[c]&&(s[c][f.attr]=f)}else if(f.curves.morph!==void 0){if(s[c]===void 0){const o=S.get(l.ID).parents.filter(function(v){return v.relationship!==void 0})[0].ID,p=S.get(o).parents[0].ID,h=S.get(p).parents[0].ID,m=S.get(h).parents[0].ID,d=T.Objects.Model[m],g={modelName:d.attrName?fe.sanitizeNodeName(d.attrName):"",morphName:T.Objects.Deformer[o].attrName};s[c]=g}s[c][f.attr]=f}}}),n.set(parseInt(r),s))}return n}parseAnimStacks(e){const t=T.Objects.AnimationStack,n={};for(const r in t){const s=S.get(parseInt(r)).children;s.length>1&&console.warn("THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers.");const i=e.get(s[0].ID);n[r]={name:t[r].attrName,layer:i}}return n}addClip(e){let t=[];const n=this;return e.layer.forEach(function(r){t=t.concat(n.generateTracks(r))}),new At(e.name,-1,t)}generateTracks(e){const t=[];let n=new E,r=new E;if(e.transform&&e.transform.decompose(n,new X,r),n=n.toArray(),r=r.toArray(),e.T!==void 0&&Object.keys(e.T.curves).length>0){const s=this.generateVectorTrack(e.modelName,e.T.curves,n,"position");s!==void 0&&t.push(s)}if(e.R!==void 0&&Object.keys(e.R.curves).length>0){const s=this.generateRotationTrack(e.modelName,e.R.curves,e.preRotation,e.postRotation,e.eulerOrder);s!==void 0&&t.push(s)}if(e.S!==void 0&&Object.keys(e.S.curves).length>0){const s=this.generateVectorTrack(e.modelName,e.S.curves,r,"scale");s!==void 0&&t.push(s)}if(e.DeformPercent!==void 0){const s=this.generateMorphTrack(e);s!==void 0&&t.push(s)}return t}generateVectorTrack(e,t,n,r){const s=this.getTimesForAllAxes(t),i=this.getKeyframeTrackValues(s,t,n);return new Pt(e+"."+r,s,i)}generateRotationTrack(e,t,n,r,s){let i,a;if(t.x!==void 0&&t.y!==void 0&&t.z!==void 0){const p=this.interpolateRotations(t.x,t.y,t.z,s);i=p[0],a=p[1]}const l=ne(0);n!==void 0&&(n=n.map(D.degToRad),n.push(l),n=new W().fromArray(n),n=new X().setFromEuler(n)),r!==void 0&&(r=r.map(D.degToRad),r.push(l),r=new W().fromArray(r),r=new X().setFromEuler(r).invert());const c=new X,f=new W,o=[];if(!a||!i)return new je(e+".quaternion",[0],[0]);for(let p=0;p<a.length;p+=3)f.set(a[p],a[p+1],a[p+2],s),c.setFromEuler(f),n!==void 0&&c.premultiply(n),r!==void 0&&c.multiply(r),p>2&&new X().fromArray(o,(p-3)/3*4).dot(c)<0&&c.set(-c.x,-c.y,-c.z,-c.w),c.toArray(o,p/3*4);return new je(e+".quaternion",i,o)}generateMorphTrack(e){const t=e.DeformPercent.curves.morph,n=t.values.map(function(s){return s/100}),r=M.getObjectByName(e.modelName).morphTargetDictionary[e.morphName];return new St(e.modelName+".morphTargetInfluences["+r+"]",t.times,n)}getTimesForAllAxes(e){let t=[];if(e.x!==void 0&&(t=t.concat(e.x.times)),e.y!==void 0&&(t=t.concat(e.y.times)),e.z!==void 0&&(t=t.concat(e.z.times)),t=t.sort(function(n,r){return n-r}),t.length>1){let n=1,r=t[0];for(let s=1;s<t.length;s++){const i=t[s];i!==r&&(t[n]=i,r=i,n++)}t=t.slice(0,n)}return t}getKeyframeTrackValues(e,t,n){const r=n,s=[];let i=-1,a=-1,l=-1;return e.forEach(function(c){if(t.x&&(i=t.x.times.indexOf(c)),t.y&&(a=t.y.times.indexOf(c)),t.z&&(l=t.z.times.indexOf(c)),i!==-1){const f=t.x.values[i];s.push(f),r[0]=f}else s.push(r[0]);if(a!==-1){const f=t.y.values[a];s.push(f),r[1]=f}else s.push(r[1]);if(l!==-1){const f=t.z.values[l];s.push(f),r[2]=f}else s.push(r[2])}),s}interpolateRotations(e,t,n,r){const s=[],i=[];s.push(e.times[0]),i.push(D.degToRad(e.values[0])),i.push(D.degToRad(t.values[0])),i.push(D.degToRad(n.values[0]));for(let a=1;a<e.values.length;a++){const l=[e.values[a-1],t.values[a-1],n.values[a-1]];if(isNaN(l[0])||isNaN(l[1])||isNaN(l[2]))continue;const c=l.map(D.degToRad),f=[e.values[a],t.values[a],n.values[a]];if(isNaN(f[0])||isNaN(f[1])||isNaN(f[2]))continue;const o=f.map(D.degToRad),p=[f[0]-l[0],f[1]-l[1],f[2]-l[2]],h=[Math.abs(p[0]),Math.abs(p[1]),Math.abs(p[2])];if(h[0]>=180||h[1]>=180||h[2]>=180){const d=Math.max(...h)/180,g=new W(...c,r),v=new W(...o,r),x=new X().setFromEuler(g),y=new X().setFromEuler(v);x.dot(y)&&y.set(-y.x,-y.y,-y.z,-y.w);const I=e.times[a-1],L=e.times[a]-I,w=new X,A=new W;for(let C=0;C<1;C+=1/d)w.copy(x.clone().slerp(y.clone(),C)),s.push(I+C*L),A.setFromQuaternion(w,r),i.push(A.x),i.push(A.y),i.push(A.z)}else s.push(e.times[a]),i.push(D.degToRad(e.values[a])),i.push(D.degToRad(t.values[a])),i.push(D.degToRad(n.values[a]))}return[s,i]}}class tn{getPrevNode(){return this.nodeStack[this.currentIndent-2]}getCurrentNode(){return this.nodeStack[this.currentIndent-1]}getCurrentProp(){return this.currentProp}pushStack(e){this.nodeStack.push(e),this.currentIndent+=1}popStack(){this.nodeStack.pop(),this.currentIndent-=1}setCurrentProp(e,t){this.currentProp=e,this.currentPropName=t}parse(e){this.currentIndent=0,this.allNodes=new tt,this.nodeStack=[],this.currentProp=[],this.currentPropName="";const t=this,n=e.split(/[\r\n]+/);return n.forEach(function(r,s){const i=r.match(/^[\s\t]*;/),a=r.match(/^[\s\t]*$/);if(i||a)return;const l=r.match("^\\t{"+t.currentIndent+"}(\\w+):(.*){",""),c=r.match("^\\t{"+t.currentIndent+"}(\\w+):[\\s\\t\\r\\n](.*)"),f=r.match("^\\t{"+(t.currentIndent-1)+"}}");l?t.parseNodeBegin(r,l):c?t.parseNodeProperty(r,c,n[++s]):f?t.popStack():r.match(/^[^\s\t}]/)&&t.parseNodePropertyContinued(r)}),this.allNodes}parseNodeBegin(e,t){const n=t[1].trim().replace(/^"/,"").replace(/"$/,""),r=t[2].split(",").map(function(l){return l.trim().replace(/^"/,"").replace(/"$/,"")}),s={name:n},i=this.parseNodeAttr(r),a=this.getCurrentNode();this.currentIndent===0?this.allNodes.add(n,s):n in a?(n==="PoseNode"?a.PoseNode.push(s):a[n].id!==void 0&&(a[n]={},a[n][a[n].id]=a[n]),i.id!==""&&(a[n][i.id]=s)):typeof i.id=="number"?(a[n]={},a[n][i.id]=s):n!=="Properties70"&&(n==="PoseNode"?a[n]=[s]:a[n]=s),typeof i.id=="number"&&(s.id=i.id),i.name!==""&&(s.attrName=i.name),i.type!==""&&(s.attrType=i.type),this.pushStack(s)}parseNodeAttr(e){let t=e[0];e[0]!==""&&(t=parseInt(e[0]),isNaN(t)&&(t=e[0]));let n="",r="";return e.length>1&&(n=e[1].replace(/^(\w+)::/,""),r=e[2]),{id:t,name:n,type:r}}parseNodeProperty(e,t,n){let r=t[1].replace(/^"/,"").replace(/"$/,"").trim(),s=t[2].replace(/^"/,"").replace(/"$/,"").trim();r==="Content"&&s===","&&(s=n.replace(/"/g,"").replace(/,$/,"").trim());const i=this.getCurrentNode();if(i.name==="Properties70"){this.parseNodeSpecialProperty(e,r,s);return}if(r==="C"){const l=s.split(",").slice(1),c=parseInt(l[0]),f=parseInt(l[1]);let o=s.split(",").slice(3);o=o.map(function(p){return p.trim().replace(/^"/,"")}),r="connections",s=[c,f],ln(s,o),i[r]===void 0&&(i[r]=[])}r==="Node"&&(i.id=s),r in i&&Array.isArray(i[r])?i[r].push(s):r!=="a"?i[r]=s:i.a=s,this.setCurrentProp(i,r),r==="a"&&s.slice(-1)!==","&&(i.a=Te(s))}parseNodePropertyContinued(e){const t=this.getCurrentNode();t.a+=e,e.slice(-1)!==","&&(t.a=Te(t.a))}parseNodeSpecialProperty(e,t,n){const r=n.split('",').map(function(f){return f.trim().replace(/^\"/,"").replace(/\s/,"_")}),s=r[0],i=r[1],a=r[2],l=r[3];let c=r[4];switch(i){case"int":case"enum":case"bool":case"ULongLong":case"double":case"Number":case"FieldOfView":c=parseFloat(c);break;case"Color":case"ColorRGB":case"Vector3D":case"Lcl_Translation":case"Lcl_Rotation":case"Lcl_Scaling":c=Te(c);break}this.getPrevNode()[s]={type:i,type2:a,flag:l,value:c},this.setCurrentProp(this.getPrevNode(),s)}}class nn{parse(e){const t=new _e(e);t.skip(23);const n=t.getUint32();if(n<6400)throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: "+n);const r=new tt;for(;!this.endOfContent(t);){const s=this.parseNode(t,n);s!==null&&r.add(s.name,s)}return r}endOfContent(e){return e.size()%16===0?(e.getOffset()+160+16&-16)>=e.size():e.getOffset()+160+16>=e.size()}parseNode(e,t){const n={},r=t>=7500?e.getUint64():e.getUint32(),s=t>=7500?e.getUint64():e.getUint32();t>=7500?e.getUint64():e.getUint32();const i=e.getUint8(),a=e.getString(i);if(r===0)return null;const l=[];for(let p=0;p<s;p++)l.push(this.parseProperty(e));const c=l.length>0?l[0]:"",f=l.length>1?l[1]:"",o=l.length>2?l[2]:"";for(n.singleProperty=s===1&&e.getOffset()===r;r>e.getOffset();){const p=this.parseNode(e,t);p!==null&&this.parseSubNode(a,n,p)}return n.propertyList=l,typeof c=="number"&&(n.id=c),f!==""&&(n.attrName=f),o!==""&&(n.attrType=o),a!==""&&(n.name=a),n}parseSubNode(e,t,n){if(n.singleProperty===!0){const r=n.propertyList[0];Array.isArray(r)?(t[n.name]=n,n.a=r):t[n.name]=r}else if(e==="Connections"&&n.name==="C"){const r=[];n.propertyList.forEach(function(s,i){i!==0&&r.push(s)}),t.connections===void 0&&(t.connections=[]),t.connections.push(r)}else if(n.name==="Properties70")Object.keys(n).forEach(function(s){t[s]=n[s]});else if(e==="Properties70"&&n.name==="P"){let r=n.propertyList[0],s=n.propertyList[1];const i=n.propertyList[2],a=n.propertyList[3];let l;r.indexOf("Lcl ")===0&&(r=r.replace("Lcl ","Lcl_")),s.indexOf("Lcl ")===0&&(s=s.replace("Lcl ","Lcl_")),s==="Color"||s==="ColorRGB"||s==="Vector"||s==="Vector3D"||s.indexOf("Lcl_")===0?l=[n.propertyList[4],n.propertyList[5],n.propertyList[6]]:l=n.propertyList[4],t[r]={type:s,type2:i,flag:a,value:l}}else t[n.name]===void 0?typeof n.id=="number"?(t[n.name]={},t[n.name][n.id]=n):t[n.name]=n:n.name==="PoseNode"?(Array.isArray(t[n.name])||(t[n.name]=[t[n.name]]),t[n.name].push(n)):t[n.name][n.id]===void 0&&(t[n.name][n.id]=n)}parseProperty(e){const t=e.getString(1);let n;switch(t){case"C":return e.getBoolean();case"D":return e.getFloat64();case"F":return e.getFloat32();case"I":return e.getInt32();case"L":return e.getInt64();case"R":return n=e.getUint32(),e.getArrayBuffer(n);case"S":return n=e.getUint32(),e.getString(n);case"Y":return e.getInt16();case"b":case"c":case"d":case"f":case"i":case"l":const r=e.getUint32(),s=e.getUint32(),i=e.getUint32();if(s===0)switch(t){case"b":case"c":return e.getBooleanArray(r);case"d":return e.getFloat64Array(r);case"f":return e.getFloat32Array(r);case"i":return e.getInt32Array(r);case"l":return e.getInt64Array(r)}const a=_t(new Uint8Array(e.getArrayBuffer(i))),l=new _e(a.buffer);switch(t){case"b":case"c":return l.getBooleanArray(r);case"d":return l.getFloat64Array(r);case"f":return l.getFloat32Array(r);case"i":return l.getInt32Array(r);case"l":return l.getInt64Array(r)}break;default:throw new Error("THREE.FBXLoader: Unknown property type "+t)}}}class _e{constructor(e,t){this.dv=new DataView(e),this.offset=0,this.littleEndian=t!==void 0?t:!0,this._textDecoder=new TextDecoder}getOffset(){return this.offset}size(){return this.dv.buffer.byteLength}skip(e){this.offset+=e}getBoolean(){return(this.getUint8()&1)===1}getBooleanArray(e){const t=[];for(let n=0;n<e;n++)t.push(this.getBoolean());return t}getUint8(){const e=this.dv.getUint8(this.offset);return this.offset+=1,e}getInt16(){const e=this.dv.getInt16(this.offset,this.littleEndian);return this.offset+=2,e}getInt32(){const e=this.dv.getInt32(this.offset,this.littleEndian);return this.offset+=4,e}getInt32Array(e){const t=[];for(let n=0;n<e;n++)t.push(this.getInt32());return t}getUint32(){const e=this.dv.getUint32(this.offset,this.littleEndian);return this.offset+=4,e}getInt64(){let e,t;return this.littleEndian?(e=this.getUint32(),t=this.getUint32()):(t=this.getUint32(),e=this.getUint32()),t&2147483648?(t=~t&4294967295,e=~e&4294967295,e===4294967295&&(t=t+1&4294967295),e=e+1&4294967295,-(t*4294967296+e)):t*4294967296+e}getInt64Array(e){const t=[];for(let n=0;n<e;n++)t.push(this.getInt64());return t}getUint64(){let e,t;return this.littleEndian?(e=this.getUint32(),t=this.getUint32()):(t=this.getUint32(),e=this.getUint32()),t*4294967296+e}getFloat32(){const e=this.dv.getFloat32(this.offset,this.littleEndian);return this.offset+=4,e}getFloat32Array(e){const t=[];for(let n=0;n<e;n++)t.push(this.getFloat32());return t}getFloat64(){const e=this.dv.getFloat64(this.offset,this.littleEndian);return this.offset+=8,e}getFloat64Array(e){const t=[];for(let n=0;n<e;n++)t.push(this.getFloat64());return t}getArrayBuffer(e){const t=this.dv.buffer.slice(this.offset,this.offset+e);return this.offset+=e,t}getString(e){const t=this.offset;let n=new Uint8Array(this.dv.buffer,t,e);this.skip(e);const r=n.indexOf(0);return r>=0&&(n=new Uint8Array(this.dv.buffer,t,r)),this._textDecoder.decode(n)}}class tt{add(e,t){this[e]=t}}function rn(u){const e="Kaydara FBX Binary  \0";return u.byteLength>=e.length&&e===rt(u,0,e.length)}function sn(u){const e=["K","a","y","d","a","r","a","\\","F","B","X","\\","B","i","n","a","r","y","\\","\\"];let t=0;function n(r){const s=u[r-1];return u=u.slice(t+r),t++,s}for(let r=0;r<e.length;++r)if(n(1)===e[r])return!1;return!0}function Ge(u){const e=/FBXVersion: (\d+)/,t=u.match(e);if(t)return parseInt(t[1]);throw new Error("THREE.FBXLoader: Cannot find the version number for the file given.")}function an(u){return u/46186158e3}const on=[];function oe(u,e,t,n){let r;switch(n.mappingType){case"ByPolygonVertex":r=u;break;case"ByPolygon":r=e;break;case"ByVertice":r=t;break;case"AllSame":r=n.indices[0];break;default:console.warn("THREE.FBXLoader: unknown attribute mapping type "+n.mappingType)}n.referenceType==="IndexToDirect"&&(r=n.indices[r]);const s=r*n.dataSize,i=s+n.dataSize;return cn(on,n.buffer,s,i)}const xe=new W,Y=new E;function nt(u){const e=new P,t=new P,n=new P,r=new P,s=new P,i=new P,a=new P,l=new P,c=new P,f=new P,o=new P,p=new P,h=u.inheritType?u.inheritType:0;u.translation&&e.setPosition(Y.fromArray(u.translation));const m=ne(0);if(u.preRotation){const b=u.preRotation.map(D.degToRad);b.push(m),t.makeRotationFromEuler(xe.fromArray(b))}if(u.rotation){const b=u.rotation.map(D.degToRad);b.push(u.eulerOrder||m),n.makeRotationFromEuler(xe.fromArray(b))}if(u.postRotation){const b=u.postRotation.map(D.degToRad);b.push(m),r.makeRotationFromEuler(xe.fromArray(b)),r.invert()}u.scale&&s.scale(Y.fromArray(u.scale)),u.scalingOffset&&a.setPosition(Y.fromArray(u.scalingOffset)),u.scalingPivot&&i.setPosition(Y.fromArray(u.scalingPivot)),u.rotationOffset&&l.setPosition(Y.fromArray(u.rotationOffset)),u.rotationPivot&&c.setPosition(Y.fromArray(u.rotationPivot)),u.parentMatrixWorld&&(o.copy(u.parentMatrix),f.copy(u.parentMatrixWorld));const d=t.clone().multiply(n).multiply(r),g=new P;g.extractRotation(f);const v=new P;v.copyPosition(f);const x=v.clone().invert().multiply(f),y=g.clone().invert().multiply(x),I=s,L=new P;if(h===0)L.copy(g).multiply(d).multiply(y).multiply(I);else if(h===1)L.copy(g).multiply(y).multiply(d).multiply(I);else{const N=new P().scale(new E().setFromMatrixScale(o)).clone().invert(),he=y.clone().multiply(N);L.copy(g).multiply(d).multiply(he).multiply(I)}const w=c.clone().invert(),A=i.clone().invert();let C=e.clone().multiply(l).multiply(c).multiply(t).multiply(n).multiply(r).multiply(w).multiply(a).multiply(i).multiply(s).multiply(A);const z=new P().copyPosition(C),_=f.clone().multiply(z);return p.copyPosition(_),C=p.clone().multiply(L),C.premultiply(f.invert()),C}function ne(u){u=u||0;const e=["ZYX","YZX","XZY","ZXY","YXZ","XYZ"];return u===6?(console.warn("THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect."),e[0]):e[u]}function Te(u){return u.split(",").map(function(t){return parseFloat(t)})}function rt(u,e,t){return e===void 0&&(e=0),t===void 0&&(t=u.byteLength),new TextDecoder().decode(new Uint8Array(u,e,t))}function ln(u,e){for(let t=0,n=u.length,r=e.length;t<r;t++,n++)u[n]=e[t]}function cn(u,e,t,n){for(let r=t,s=0;r<n;r++,s++)u[s]=e[r];return u}const un=/^[og]\s*(.+)?/,pn=/^mtllib /,fn=/^usemtl /,hn=/^usemap /,Xe=/\s+/,He=new E,Ie=new E,Ke=new E,We=new E,R=new E,le=new U;function mn(){const u={objects:[],object:{},vertices:[],normals:[],colors:[],uvs:[],materials:{},materialLibraries:[],startObject:function(e,t){if(this.object&&this.object.fromDeclaration===!1){this.object.name=e,this.object.fromDeclaration=t!==!1;return}const n=this.object&&typeof this.object.currentMaterial=="function"?this.object.currentMaterial():void 0;if(this.object&&typeof this.object._finalize=="function"&&this.object._finalize(!0),this.object={name:e||"",fromDeclaration:t!==!1,geometry:{vertices:[],normals:[],colors:[],uvs:[],hasUVIndices:!1},materials:[],smooth:!0,startMaterial:function(r,s){const i=this._finalize(!1);i&&(i.inherited||i.groupCount<=0)&&this.materials.splice(i.index,1);const a={index:this.materials.length,name:r||"",mtllib:Array.isArray(s)&&s.length>0?s[s.length-1]:"",smooth:i!==void 0?i.smooth:this.smooth,groupStart:i!==void 0?i.groupEnd:0,groupEnd:-1,groupCount:-1,inherited:!1,clone:function(l){const c={index:typeof l=="number"?l:this.index,name:this.name,mtllib:this.mtllib,smooth:this.smooth,groupStart:0,groupEnd:-1,groupCount:-1,inherited:!1};return c.clone=this.clone.bind(c),c}};return this.materials.push(a),a},currentMaterial:function(){if(this.materials.length>0)return this.materials[this.materials.length-1]},_finalize:function(r){const s=this.currentMaterial();if(s&&s.groupEnd===-1&&(s.groupEnd=this.geometry.vertices.length/3,s.groupCount=s.groupEnd-s.groupStart,s.inherited=!1),r&&this.materials.length>1)for(let i=this.materials.length-1;i>=0;i--)this.materials[i].groupCount<=0&&this.materials.splice(i,1);return r&&this.materials.length===0&&this.materials.push({name:"",smooth:this.smooth}),s}},n&&n.name&&typeof n.clone=="function"){const r=n.clone(0);r.inherited=!0,this.object.materials.push(r)}this.objects.push(this.object)},finalize:function(){this.object&&typeof this.object._finalize=="function"&&this.object._finalize(!0)},parseVertexIndex:function(e,t){const n=parseInt(e,10);return(n>=0?n-1:n+t/3)*3},parseNormalIndex:function(e,t){const n=parseInt(e,10);return(n>=0?n-1:n+t/3)*3},parseUVIndex:function(e,t){const n=parseInt(e,10);return(n>=0?n-1:n+t/2)*2},addVertex:function(e,t,n){const r=this.vertices,s=this.object.geometry.vertices;s.push(r[e+0],r[e+1],r[e+2]),s.push(r[t+0],r[t+1],r[t+2]),s.push(r[n+0],r[n+1],r[n+2])},addVertexPoint:function(e){const t=this.vertices;this.object.geometry.vertices.push(t[e+0],t[e+1],t[e+2])},addVertexLine:function(e){const t=this.vertices;this.object.geometry.vertices.push(t[e+0],t[e+1],t[e+2])},addNormal:function(e,t,n){const r=this.normals,s=this.object.geometry.normals;s.push(r[e+0],r[e+1],r[e+2]),s.push(r[t+0],r[t+1],r[t+2]),s.push(r[n+0],r[n+1],r[n+2])},addFaceNormal:function(e,t,n){const r=this.vertices,s=this.object.geometry.normals;He.fromArray(r,e),Ie.fromArray(r,t),Ke.fromArray(r,n),R.subVectors(Ke,Ie),We.subVectors(He,Ie),R.cross(We),R.normalize(),s.push(R.x,R.y,R.z),s.push(R.x,R.y,R.z),s.push(R.x,R.y,R.z)},addColor:function(e,t,n){const r=this.colors,s=this.object.geometry.colors;r[e]!==void 0&&s.push(r[e+0],r[e+1],r[e+2]),r[t]!==void 0&&s.push(r[t+0],r[t+1],r[t+2]),r[n]!==void 0&&s.push(r[n+0],r[n+1],r[n+2])},addUV:function(e,t,n){const r=this.uvs,s=this.object.geometry.uvs;s.push(r[e+0],r[e+1]),s.push(r[t+0],r[t+1]),s.push(r[n+0],r[n+1])},addDefaultUV:function(){const e=this.object.geometry.uvs;e.push(0,0),e.push(0,0),e.push(0,0)},addUVLine:function(e){const t=this.uvs;this.object.geometry.uvs.push(t[e+0],t[e+1])},addFace:function(e,t,n,r,s,i,a,l,c){const f=this.vertices.length;let o=this.parseVertexIndex(e,f),p=this.parseVertexIndex(t,f),h=this.parseVertexIndex(n,f);if(this.addVertex(o,p,h),this.addColor(o,p,h),a!==void 0&&a!==""){const m=this.normals.length;o=this.parseNormalIndex(a,m),p=this.parseNormalIndex(l,m),h=this.parseNormalIndex(c,m),this.addNormal(o,p,h)}else this.addFaceNormal(o,p,h);if(r!==void 0&&r!==""){const m=this.uvs.length;o=this.parseUVIndex(r,m),p=this.parseUVIndex(s,m),h=this.parseUVIndex(i,m),this.addUV(o,p,h),this.object.geometry.hasUVIndices=!0}else this.addDefaultUV()},addPointGeometry:function(e){this.object.geometry.type="Points";const t=this.vertices.length;for(let n=0,r=e.length;n<r;n++){const s=this.parseVertexIndex(e[n],t);this.addVertexPoint(s),this.addColor(s)}},addLineGeometry:function(e,t){this.object.geometry.type="Line";const n=this.vertices.length,r=this.uvs.length;for(let s=0,i=e.length;s<i;s++)this.addVertexLine(this.parseVertexIndex(e[s],n));for(let s=0,i=t.length;s<i;s++)this.addUVLine(this.parseUVIndex(t[s],r))}};return u.startObject("",!1),u}class yn extends pe{constructor(e){super(e),this.materials=null}load(e,t,n,r){const s=this,i=new Ne(this.manager);i.setPath(this.path),i.setRequestHeader(this.requestHeader),i.setWithCredentials(this.withCredentials),i.load(e,function(a){try{t(s.parse(a))}catch(l){r?r(l):console.error(l),s.manager.itemError(e)}},n,r)}setMaterials(e){return this.materials=e,this}parse(e){const t=new mn;e.indexOf(`\r
`)!==-1&&(e=e.replace(/\r\n/g,`
`)),e.indexOf(`\\
`)!==-1&&(e=e.replace(/\\\n/g,""));const n=e.split(`
`);let r=[];for(let a=0,l=n.length;a<l;a++){const c=n[a].trimStart();if(c.length===0)continue;const f=c.charAt(0);if(f!=="#")if(f==="v"){const o=c.split(Xe);switch(o[0]){case"v":t.vertices.push(parseFloat(o[1]),parseFloat(o[2]),parseFloat(o[3])),o.length>=7?(le.setRGB(parseFloat(o[4]),parseFloat(o[5]),parseFloat(o[6]),k),t.colors.push(le.r,le.g,le.b)):t.colors.push(void 0,void 0,void 0);break;case"vn":t.normals.push(parseFloat(o[1]),parseFloat(o[2]),parseFloat(o[3]));break;case"vt":t.uvs.push(parseFloat(o[1]),parseFloat(o[2]));break}}else if(f==="f"){const p=c.slice(1).trim().split(Xe),h=[];for(let d=0,g=p.length;d<g;d++){const v=p[d];if(v.length>0){const x=v.split("/");h.push(x)}}const m=h[0];for(let d=1,g=h.length-1;d<g;d++){const v=h[d],x=h[d+1];t.addFace(m[0],v[0],x[0],m[1],v[1],x[1],m[2],v[2],x[2])}}else if(f==="l"){const o=c.substring(1).trim().split(" ");let p=[];const h=[];if(c.indexOf("/")===-1)p=o;else for(let m=0,d=o.length;m<d;m++){const g=o[m].split("/");g[0]!==""&&p.push(g[0]),g[1]!==""&&h.push(g[1])}t.addLineGeometry(p,h)}else if(f==="p"){const p=c.slice(1).trim().split(" ");t.addPointGeometry(p)}else if((r=un.exec(c))!==null){const o=(" "+r[0].slice(1).trim()).slice(1);t.startObject(o)}else if(fn.test(c))t.object.startMaterial(c.substring(7).trim(),t.materialLibraries);else if(pn.test(c))t.materialLibraries.push(c.substring(7).trim());else if(hn.test(c))console.warn('THREE.OBJLoader: Rendering identifier "usemap" not supported. Textures must be defined in MTL files.');else if(f==="s"){if(r=c.split(" "),r.length>1){const p=r[1].trim().toLowerCase();t.object.smooth=p!=="0"&&p!=="off"}else t.object.smooth=!0;const o=t.object.currentMaterial();o&&(o.smooth=t.object.smooth)}else{if(c==="\0")continue;console.warn('THREE.OBJLoader: Unexpected line: "'+c+'"')}}t.finalize();const s=new Fe;if(s.materialLibraries=[].concat(t.materialLibraries),!(t.objects.length===1&&t.objects[0].geometry.vertices.length===0)===!0)for(let a=0,l=t.objects.length;a<l;a++){const c=t.objects[a],f=c.geometry,o=c.materials,p=f.type==="Line",h=f.type==="Points";let m=!1;if(f.vertices.length===0)continue;const d=new $;d.setAttribute("position",new O(f.vertices,3)),f.normals.length>0&&d.setAttribute("normal",new O(f.normals,3)),f.colors.length>0&&(m=!0,d.setAttribute("color",new O(f.colors,3))),f.hasUVIndices===!0&&d.setAttribute("uv",new O(f.uvs,2));const g=[];for(let x=0,y=o.length;x<y;x++){const I=o[x],L=I.name+"_"+I.smooth+"_"+m;let w=t.materials[L];if(this.materials!==null){if(w=this.materials.create(I.name),p&&w&&!(w instanceof ue)){const A=new ue;ze.prototype.copy.call(A,w),A.color.copy(w.color),w=A}else if(h&&w&&!(w instanceof ae)){const A=new ae({size:10,sizeAttenuation:!1});ze.prototype.copy.call(A,w),A.color.copy(w.color),A.map=w.map,w=A}}w===void 0&&(p?w=new ue:h?w=new ae({size:1,sizeAttenuation:!1}):w=new ce,w.name=I.name,w.flatShading=!I.smooth,w.vertexColors=m,t.materials[L]=w),g.push(w)}let v;if(g.length>1){for(let x=0,y=o.length;x<y;x++){const I=o[x];d.addGroup(I.groupStart,I.groupCount,x)}p?v=new Ue(d,g):h?v=new ye(d,g):v=new be(d,g)}else p?v=new Ue(d,g[0]):h?v=new ye(d,g[0]):v=new be(d,g[0]);v.name=c.name,s.add(v)}else if(t.vertices.length>0){const a=new ae({size:1,sizeAttenuation:!1}),l=new $;l.setAttribute("position",new O(t.vertices,3)),t.colors.length>0&&t.colors[0]!==void 0&&(l.setAttribute("color",new O(t.colors,3)),a.vertexColors=!0);const c=new ye(l,a);s.add(c)}return s}}export{gn as F,yn as O};
